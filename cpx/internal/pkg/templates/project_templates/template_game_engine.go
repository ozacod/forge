package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&GameEngineTemplate{})
}

// GameEngineTemplate generates a game engine starter
type GameEngineTemplate struct {
	BaseTemplateHelper
}

func (t *GameEngineTemplate) Name() string {
	return "Game Engine"
}

func (t *GameEngineTemplate) Description() string {
	return "Game engine starter with ECS pattern"
}

func (t *GameEngineTemplate) Dependencies() []string {
	return []string{"sdl2", "glm"}
}

func (t *GameEngineTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"include/" + projectName + "/ecs",
		"include/" + projectName + "/core",
		"src",
		"src/ecs",
		"src/core",
		"assets",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate Game class
	gameH := t.generateGameHeader(projectName)
	if err := t.WriteFile(projectName, "include/"+projectName+"/core/game.hpp", gameH); err != nil {
		return err
	}

	gameCpp := t.generateGameSource(projectName)
	if err := t.WriteFile(projectName, "src/core/game.cpp", gameCpp); err != nil {
		return err
	}

	// Generate Entity class
	entityH := t.generateEntityHeader(projectName)
	if err := t.WriteFile(projectName, "include/"+projectName+"/ecs/entity.hpp", entityH); err != nil {
		return err
	}

	// Generate Component base
	componentH := t.generateComponentHeader(projectName)
	if err := t.WriteFile(projectName, "include/"+projectName+"/ecs/component.hpp", componentH); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *GameEngineTemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - Game Engine
// Generated by cpx

#include "%s/core/game.hpp"

int main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;

    Game game("%s", 1280, 720);
    
    if (!game.init()) {
        return 1;
    }
    
    game.run();
    
    return 0;
}
`, projectName, projectName, projectName)
}

func (t *GameEngineTemplate) generateGameHeader(projectName string) string {
	guardName := fmt.Sprintf("%s_CORE_GAME_HPP", toUpperSnakeCase(projectName))
	return fmt.Sprintf(`#ifndef %s
#define %s

#include <SDL.h>
#include <string>
#include <vector>
#include <memory>
#include "%s/ecs/entity.hpp"

class Game {
public:
    Game(const std::string& title, int width, int height);
    ~Game();

    bool init();
    void run();
    void quit();

    // Entity management
    Entity& createEntity();
    void removeEntity(Entity& entity);

    // Accessors
    SDL_Renderer* getRenderer() const { return m_renderer; }
    int getWidth() const { return m_width; }
    int getHeight() const { return m_height; }
    bool isRunning() const { return m_running; }

private:
    void handleEvents();
    void update(float deltaTime);
    void render();

    std::string m_title;
    int m_width;
    int m_height;
    bool m_running = false;

    SDL_Window* m_window = nullptr;
    SDL_Renderer* m_renderer = nullptr;

    std::vector<std::unique_ptr<Entity>> m_entities;
    uint32_t m_nextEntityId = 0;
};

#endif // %s
`, guardName, guardName, projectName, guardName)
}

func (t *GameEngineTemplate) generateGameSource(projectName string) string {
	return fmt.Sprintf(`#include "%s/core/game.hpp"
#include <iostream>
#include <algorithm>

Game::Game(const std::string& title, int width, int height)
    : m_title(title), m_width(width), m_height(height) {}

Game::~Game() {
    if (m_renderer) {
        SDL_DestroyRenderer(m_renderer);
    }
    if (m_window) {
        SDL_DestroyWindow(m_window);
    }
    SDL_Quit();
}

bool Game::init() {
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) < 0) {
        std::cerr << "SDL could not initialize: " << SDL_GetError() << std::endl;
        return false;
    }

    m_window = SDL_CreateWindow(
        m_title.c_str(),
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        m_width,
        m_height,
        SDL_WINDOW_SHOWN
    );

    if (!m_window) {
        std::cerr << "Window could not be created: " << SDL_GetError() << std::endl;
        return false;
    }

    m_renderer = SDL_CreateRenderer(m_window, -1, 
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    if (!m_renderer) {
        std::cerr << "Renderer could not be created: " << SDL_GetError() << std::endl;
        return false;
    }

    m_running = true;
    return true;
}

void Game::run() {
    Uint32 lastTime = SDL_GetTicks();

    while (m_running) {
        Uint32 currentTime = SDL_GetTicks();
        float deltaTime = (currentTime - lastTime) / 1000.0f;
        lastTime = currentTime;

        handleEvents();
        update(deltaTime);
        render();
    }
}

void Game::quit() {
    m_running = false;
}

void Game::handleEvents() {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_QUIT:
                quit();
                break;
            case SDL_KEYDOWN:
                if (event.key.keysym.sym == SDLK_ESCAPE) {
                    quit();
                }
                break;
        }
    }
}

void Game::update(float deltaTime) {
    for (auto& entity : m_entities) {
        entity->update(deltaTime);
    }
}

void Game::render() {
    SDL_SetRenderDrawColor(m_renderer, 30, 30, 40, 255);
    SDL_RenderClear(m_renderer);

    for (auto& entity : m_entities) {
        entity->render(m_renderer);
    }

    SDL_RenderPresent(m_renderer);
}

Entity& Game::createEntity() {
    auto entity = std::make_unique<Entity>(m_nextEntityId++);
    m_entities.push_back(std::move(entity));
    return *m_entities.back();
}

void Game::removeEntity(Entity& entity) {
    m_entities.erase(
        std::remove_if(m_entities.begin(), m_entities.end(),
            [&entity](const std::unique_ptr<Entity>& e) {
                return e->getId() == entity.getId();
            }),
        m_entities.end()
    );
}
`, projectName)
}

func (t *GameEngineTemplate) generateEntityHeader(projectName string) string {
	guardName := fmt.Sprintf("%s_ECS_ENTITY_HPP", toUpperSnakeCase(projectName))
	return fmt.Sprintf(`#ifndef %s
#define %s

#include <SDL.h>
#include <vector>
#include <memory>
#include <typeindex>
#include <unordered_map>
#include "%s/ecs/component.hpp"

class Entity {
public:
    explicit Entity(uint32_t id) : m_id(id) {}
    virtual ~Entity() = default;

    uint32_t getId() const { return m_id; }

    template<typename T, typename... Args>
    T& addComponent(Args&&... args) {
        auto component = std::make_unique<T>(std::forward<Args>(args)...);
        T& ref = *component;
        m_components[std::type_index(typeid(T))] = std::move(component);
        return ref;
    }

    template<typename T>
    T* getComponent() {
        auto it = m_components.find(std::type_index(typeid(T)));
        if (it != m_components.end()) {
            return static_cast<T*>(it->second.get());
        }
        return nullptr;
    }

    template<typename T>
    bool hasComponent() const {
        return m_components.find(std::type_index(typeid(T))) != m_components.end();
    }

    template<typename T>
    void removeComponent() {
        m_components.erase(std::type_index(typeid(T)));
    }

    virtual void update(float deltaTime) {
        for (auto& [type, component] : m_components) {
            component->update(deltaTime);
        }
    }

    virtual void render(SDL_Renderer* renderer) {
        for (auto& [type, component] : m_components) {
            component->render(renderer);
        }
    }

private:
    uint32_t m_id;
    std::unordered_map<std::type_index, std::unique_ptr<Component>> m_components;
};

#endif // %s
`, guardName, guardName, projectName, guardName)
}

func (t *GameEngineTemplate) generateComponentHeader(projectName string) string {
	guardName := fmt.Sprintf("%s_ECS_COMPONENT_HPP", toUpperSnakeCase(projectName))
	return fmt.Sprintf(`#ifndef %s
#define %s

#include <SDL.h>

class Component {
public:
    virtual ~Component() = default;
    virtual void update(float deltaTime) { (void)deltaTime; }
    virtual void render(SDL_Renderer* renderer) { (void)renderer; }
};

// Example: Transform Component
class TransformComponent : public Component {
public:
    float x = 0.0f;
    float y = 0.0f;
    float width = 32.0f;
    float height = 32.0f;
    float rotation = 0.0f;
    float scale = 1.0f;

    TransformComponent() = default;
    TransformComponent(float x, float y, float w = 32.0f, float h = 32.0f)
        : x(x), y(y), width(w), height(h) {}
};

// Example: Sprite Component
class SpriteComponent : public Component {
public:
    SDL_Color color = {255, 255, 255, 255};
    TransformComponent* transform = nullptr;

    SpriteComponent() = default;
    explicit SpriteComponent(SDL_Color c) : color(c) {}

    void setTransform(TransformComponent* t) { transform = t; }

    void render(SDL_Renderer* renderer) override {
        if (!transform) return;
        
        SDL_Rect rect = {
            static_cast<int>(transform->x),
            static_cast<int>(transform->y),
            static_cast<int>(transform->width * transform->scale),
            static_cast<int>(transform->height * transform->scale)
        };
        
        SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);
        SDL_RenderFillRect(renderer, &rect);
    }
};

// Example: Velocity Component
class VelocityComponent : public Component {
public:
    float vx = 0.0f;
    float vy = 0.0f;
    TransformComponent* transform = nullptr;

    VelocityComponent() = default;
    VelocityComponent(float vx, float vy) : vx(vx), vy(vy) {}

    void setTransform(TransformComponent* t) { transform = t; }

    void update(float deltaTime) override {
        if (!transform) return;
        transform->x += vx * deltaTime;
        transform->y += vy * deltaTime;
    }
};

#endif // %s
`, guardName, guardName, guardName)
}

func (t *GameEngineTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages
find_package(SDL2 CONFIG REQUIRED)
find_package(glm CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
    src/core/game.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    $<TARGET_NAME_IF_EXISTS:SDL2::SDL2main>
    $<IF:$<TARGET_EXISTS:SDL2::SDL2>,SDL2::SDL2,SDL2::SDL2-static>
    glm::glm
)

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *GameEngineTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A game engine starter with Entity-Component-System (ECS) pattern.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
cpx run
`+"```"+`

## Architecture

### Entity-Component-System (ECS)

- **Entity**: A container for components with a unique ID
- **Component**: Data and behavior that can be attached to entities
- **Game**: Main game loop and entity management

### Included Components

- `+"`TransformComponent`"+`: Position, rotation, and scale
- `+"`SpriteComponent`"+`: Colored rectangle rendering
- `+"`VelocityComponent`"+`: Movement with velocity

### Example Usage

`+"```"+`cpp
// In your game code:
Entity& player = game.createEntity();

auto& transform = player.addComponent<TransformComponent>(100.0f, 100.0f, 32.0f, 32.0f);
auto& sprite = player.addComponent<SpriteComponent>(SDL_Color{255, 0, 0, 255});
auto& velocity = player.addComponent<VelocityComponent>(50.0f, 0.0f);

sprite.setTransform(&transform);
velocity.setTransform(&transform);
`+"```"+`

## Dependencies

- SDL2
- GLM (OpenGL Mathematics)

## License

MIT
`, projectName)
}
