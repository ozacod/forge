package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&SDL2Template{})
}

// SDL2Template generates an SDL2 GUI application
type SDL2Template struct {
	BaseTemplateHelper
}

func (t *SDL2Template) Name() string {
	return "SDL2"
}

func (t *SDL2Template) Description() string {
	return "GUI application with SDL2 rendering"
}

func (t *SDL2Template) Dependencies() []string {
	return []string{"sdl2", "sdl2-image", "sdl2-ttf"}
}

func (t *SDL2Template) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"assets",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *SDL2Template) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - SDL2 Application
// Generated by cpx

#include <SDL.h>
#include <cstdio>

const int SCREEN_WIDTH = 800;
const int SCREEN_HEIGHT = 600;

int main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;

    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        std::fprintf(stderr, "SDL could not initialize! SDL_Error: %%s\n", SDL_GetError());
        return 1;
    }

    // Create window
    SDL_Window* window = SDL_CreateWindow(
        "%s",
        SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED,
        SCREEN_WIDTH,
        SCREEN_HEIGHT,
        SDL_WINDOW_SHOWN
    );
    
    if (window == nullptr) {
        std::fprintf(stderr, "Window could not be created! SDL_Error: %%s\n", SDL_GetError());
        SDL_Quit();
        return 1;
    }

    // Create renderer
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (renderer == nullptr) {
        std::fprintf(stderr, "Renderer could not be created! SDL_Error: %%s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return 1;
    }

    // Main loop
    bool running = true;
    SDL_Event event;
    
    // Color animation
    Uint8 r = 100, g = 100, b = 200;
    int colorDir = 1;
    Uint32 lastTime = SDL_GetTicks();

    while (running) {
        // Handle events
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            }
            if (event.type == SDL_KEYDOWN) {
                if (event.key.keysym.sym == SDLK_ESCAPE) {
                    running = false;
                }
            }
        }

        // Update color animation
        Uint32 currentTime = SDL_GetTicks();
        if (currentTime - lastTime >= 16) { // ~60 FPS
            lastTime = currentTime;
            
            r += colorDir;
            if (r >= 200 || r <= 50) colorDir = -colorDir;
        }

        // Clear screen
        SDL_SetRenderDrawColor(renderer, r, g, b, 255);
        SDL_RenderClear(renderer);

        // Draw a rectangle
        SDL_Rect rect = {SCREEN_WIDTH / 2 - 50, SCREEN_HEIGHT / 2 - 50, 100, 100};
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &rect);

        // Present
        SDL_RenderPresent(renderer);
    }

    // Cleanup
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}
`, projectName, projectName)
}

func (t *SDL2Template) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find SDL2
find_package(SDL2 CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    $<TARGET_NAME_IF_EXISTS:SDL2::SDL2main>
    $<IF:$<TARGET_EXISTS:SDL2::SDL2>,SDL2::SDL2,SDL2::SDL2-static>
)

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *SDL2Template) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

An SDL2 GUI application with basic rendering.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
cpx run
`+"```"+`

## Controls

- **ESC**: Quit application

## Features

- SDL2 window with renderer
- Color animation background
- Event handling (keyboard, quit)
- 60 FPS frame limiting

## Dependencies

- SDL2
- SDL2_image (optional)
- SDL2_ttf (optional)

## License

MIT
`, projectName)
}
