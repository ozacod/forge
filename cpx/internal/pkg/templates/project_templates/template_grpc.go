package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&GRPCTemplate{})
}

// GRPCTemplate generates a gRPC service
type GRPCTemplate struct {
	BaseTemplateHelper
}

func (t *GRPCTemplate) Name() string {
	return "gRPC"
}

func (t *GRPCTemplate) Description() string {
	return "gRPC service with protobuf"
}

func (t *GRPCTemplate) Dependencies() []string {
	return []string{"grpc", "protobuf"}
}

func (t *GRPCTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"proto",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate proto file
	protoFile := t.generateProtoFile(projectName)
	if err := t.WriteFile(projectName, "proto/"+projectName+".proto", protoFile); err != nil {
		return err
	}

	// Generate server main.cpp
	serverMain := t.generateServerMain(projectName)
	if err := t.WriteFile(projectName, "src/server_main.cpp", serverMain); err != nil {
		return err
	}

	// Generate client main.cpp
	clientMain := t.generateClientMain(projectName)
	if err := t.WriteFile(projectName, "src/client_main.cpp", clientMain); err != nil {
		return err
	}

	// Generate service implementation
	serviceImpl := t.generateServiceImpl(projectName)
	if err := t.WriteFile(projectName, "src/service_impl.cpp", serviceImpl); err != nil {
		return err
	}

	// Generate service header
	serviceHeader := t.generateServiceHeader(projectName)
	if err := t.WriteFile(projectName, "include/"+projectName+"/service_impl.hpp", serviceHeader); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *GRPCTemplate) generateProtoFile(projectName string) string {
	return fmt.Sprintf(`syntax = "proto3";

package %s;

option cc_enable_arenas = true;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  
  // Server-side streaming
  rpc SayHelloStream (HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greeting.
message HelloReply {
  string message = 1;
}
`, projectName)
}

func (t *GRPCTemplate) generateServerMain(projectName string) string {
	return fmt.Sprintf(`// %s - gRPC Server
// Generated by cpx

#include <iostream>
#include <memory>
#include <string>

#include <grpcpp/grpcpp.h>
#include "%s/service_impl.hpp"

void RunServer() {
    std::string server_address("0.0.0.0:50051");
    GreeterServiceImpl service;

    grpc::ServerBuilder builder;
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    builder.RegisterService(&service);
    
    std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
    std::cout << "Server listening on " << server_address << std::endl;
    
    server->Wait();
}

int main() {
    RunServer();
    return 0;
}
`, projectName, projectName)
}

func (t *GRPCTemplate) generateClientMain(projectName string) string {
	return fmt.Sprintf(`// %s - gRPC Client
// Generated by cpx

#include <iostream>
#include <memory>
#include <string>

#include <grpcpp/grpcpp.h>
#include "%s.grpc.pb.h"

class GreeterClient {
public:
    GreeterClient(std::shared_ptr<grpc::Channel> channel)
        : stub_(%s::Greeter::NewStub(channel)) {}

    std::string SayHello(const std::string& name) {
        %s::HelloRequest request;
        request.set_name(name);

        %s::HelloReply reply;
        grpc::ClientContext context;

        grpc::Status status = stub_->SayHello(&context, request, &reply);

        if (status.ok()) {
            return reply.message();
        } else {
            std::cerr << status.error_code() << ": " << status.error_message() << std::endl;
            return "RPC failed";
        }
    }

private:
    std::unique_ptr<%s::Greeter::Stub> stub_;
};

int main(int argc, char** argv) {
    std::string target_str = "localhost:50051";
    
    GreeterClient greeter(
        grpc::CreateChannel(target_str, grpc::InsecureChannelCredentials())
    );
    
    std::string user = (argc > 1) ? argv[1] : "World";
    std::string reply = greeter.SayHello(user);
    std::cout << "Greeter received: " << reply << std::endl;

    return 0;
}
`, projectName, projectName, projectName, projectName, projectName, projectName)
}

func (t *GRPCTemplate) generateServiceHeader(projectName string) string {
	guardName := fmt.Sprintf("%s_SERVICE_IMPL_HPP", toUpperSnakeCase(projectName))
	return fmt.Sprintf(`#ifndef %s
#define %s

#include <grpcpp/grpcpp.h>
#include "%s.grpc.pb.h"

class GreeterServiceImpl final : public %s::Greeter::Service {
    grpc::Status SayHello(grpc::ServerContext* context,
                          const %s::HelloRequest* request,
                          %s::HelloReply* reply) override;

    grpc::Status SayHelloStream(grpc::ServerContext* context,
                                const %s::HelloRequest* request,
                                grpc::ServerWriter<%s::HelloReply>* writer) override;
};

#endif // %s
`, guardName, guardName, projectName, projectName, projectName, projectName, projectName, projectName, guardName)
}

func (t *GRPCTemplate) generateServiceImpl(projectName string) string {
	return fmt.Sprintf(`#include "%s/service_impl.hpp"
#include <thread>
#include <chrono>

grpc::Status GreeterServiceImpl::SayHello(grpc::ServerContext* context,
                                          const %s::HelloRequest* request,
                                          %s::HelloReply* reply) {
    (void)context;
    std::string prefix("Hello ");
    reply->set_message(prefix + request->name());
    return grpc::Status::OK;
}

grpc::Status GreeterServiceImpl::SayHelloStream(grpc::ServerContext* context,
                                                const %s::HelloRequest* request,
                                                grpc::ServerWriter<%s::HelloReply>* writer) {
    (void)context;
    for (int i = 0; i < 5; i++) {
        %s::HelloReply reply;
        reply.set_message("Hello " + request->name() + " #" + std::to_string(i + 1));
        writer->Write(reply);
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    return grpc::Status::OK;
}
`, projectName, projectName, projectName, projectName, projectName, projectName)
}

func (t *GRPCTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages
find_package(protobuf CONFIG REQUIRED)
find_package(gRPC CONFIG REQUIRED)

# Proto file
get_filename_component(proto_file "proto/%s.proto" ABSOLUTE)
get_filename_component(proto_path "${proto_file}" PATH)

# Generated sources
set(proto_srcs "${CMAKE_CURRENT_BINARY_DIR}/%s.pb.cc")
set(proto_hdrs "${CMAKE_CURRENT_BINARY_DIR}/%s.pb.h")
set(grpc_srcs "${CMAKE_CURRENT_BINARY_DIR}/%s.grpc.pb.cc")
set(grpc_hdrs "${CMAKE_CURRENT_BINARY_DIR}/%s.grpc.pb.h")

find_program(_PROTOBUF_PROTOC protoc)
find_program(_GRPC_CPP_PLUGIN_EXECUTABLE grpc_cpp_plugin)

# Generate protobuf and gRPC sources
add_custom_command(
    OUTPUT "${proto_srcs}" "${proto_hdrs}" "${grpc_srcs}" "${grpc_hdrs}"
    COMMAND ${_PROTOBUF_PROTOC}
    ARGS --grpc_out "${CMAKE_CURRENT_BINARY_DIR}"
         --cpp_out "${CMAKE_CURRENT_BINARY_DIR}"
         -I "${proto_path}"
         --plugin=protoc-gen-grpc="${_GRPC_CPP_PLUGIN_EXECUTABLE}"
         "${proto_file}"
    DEPENDS "${proto_file}"
)

# Proto library
add_library(proto_lib
    ${proto_srcs}
    ${proto_hdrs}
    ${grpc_srcs}
    ${grpc_hdrs}
)

target_link_libraries(proto_lib PUBLIC
    protobuf::libprotobuf
    gRPC::grpc++
)

target_include_directories(proto_lib PUBLIC
    ${CMAKE_CURRENT_BINARY_DIR}
)

# Server executable
add_executable(${PROJECT_NAME}_server
    src/server_main.cpp
    src/service_impl.cpp
)

target_include_directories(${PROJECT_NAME}_server PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_BINARY_DIR}
)

target_link_libraries(${PROJECT_NAME}_server PRIVATE
    proto_lib
)

# Client executable
add_executable(${PROJECT_NAME}_client
    src/client_main.cpp
)

target_include_directories(${PROJECT_NAME}_client PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_BINARY_DIR}
)

target_link_libraries(${PROJECT_NAME}_client PRIVATE
    proto_lib
)
`, projectName, cppStandard, projectName, projectName, projectName, projectName, projectName)
}

func (t *GRPCTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A gRPC service with Protocol Buffers.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

Start the server:
`+"```"+`bash
./build/%s_server
`+"```"+`

In another terminal, run the client:
`+"```"+`bash
./build/%s_client [name]
`+"```"+`

## Proto Definition

The service is defined in `+"`proto/%s.proto`"+`:
- `+"`SayHello`"+`: Unary RPC - sends a greeting
- `+"`SayHelloStream`"+`: Server streaming RPC - sends multiple greetings

## Dependencies

- gRPC
- Protocol Buffers

## License

MIT
`, projectName, projectName, projectName, projectName)
}
