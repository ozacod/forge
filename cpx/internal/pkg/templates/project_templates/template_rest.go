package project_templates

import (
	"fmt"

	"github.com/ozacod/cpx/internal/pkg/templates"
)

func init() {
	RegisterTemplate(&RESTTemplate{})
}

// RESTTemplate generates a REST API using Crow
type RESTTemplate struct {
	BaseTemplateHelper
}

func (t *RESTTemplate) Name() string {
	return "REST API"
}

func (t *RESTTemplate) Description() string {
	return "REST API server with Crow framework"
}

func (t *RESTTemplate) Dependencies() []string {
	return []string{"crow"}
}

func (t *RESTTemplate) Generate(config TemplateConfig) error {
	projectName := config.ProjectName

	// Create directory structure
	dirs := []string{
		"include/" + projectName,
		"src",
		"docs",
	}
	if err := t.CreateProjectStructure(projectName, dirs); err != nil {
		return err
	}

	// Generate main.cpp
	mainCpp := t.generateMainCpp(projectName)
	if err := t.WriteFile(projectName, "src/main.cpp", mainCpp); err != nil {
		return err
	}

	// Generate version header
	versionHpp := templates.GenerateVersionHpp(projectName, "0.1.0")
	if err := t.WriteFile(projectName, "include/"+projectName+"/version.hpp", versionHpp); err != nil {
		return err
	}

	// Generate build system files (vcpkg only)
	cmakeLists := t.generateCMakeLists(projectName, config.CppStandard)
	if err := t.WriteFile(projectName, "CMakeLists.txt", cmakeLists); err != nil {
		return err
	}
	cmakePresets := templates.GenerateCMakePresets()
	if err := t.WriteFile(projectName, "CMakePresets.json", cmakePresets); err != nil {
		return err
	}
	if err := t.SetupVcpkg(projectName, t.Dependencies()); err != nil {
		return fmt.Errorf("failed to setup vcpkg: %w", err)
	}

	// Generate common files
	if err := t.GenerateCommonFiles(config); err != nil {
		return err
	}

	// Generate README
	readme := t.generateReadme(projectName)
	if err := t.WriteFile(projectName, "README.md", readme); err != nil {
		return err
	}

	// Initialize git
	_ = t.InitGitRepo(projectName)

	t.PrintSuccess(projectName)
	return nil
}

func (t *RESTTemplate) generateMainCpp(projectName string) string {
	return fmt.Sprintf(`// %s - REST API Server
// Generated by cpx

#include <crow.h>
#include <vector>
#include <string>
#include <mutex>

// Simple in-memory data store
struct Item {
    int id;
    std::string name;
    std::string description;
};

std::vector<Item> items;
std::mutex items_mutex;
int next_id = 1;

int main() {
    crow::SimpleApp app;

    // GET /
    CROW_ROUTE(app, "/")
    ([]() {
        crow::json::wvalue response;
        response["message"] = "Welcome to %s API";
        response["version"] = "0.1.0";
        return response;
    });

    // GET /items
    CROW_ROUTE(app, "/items")
    ([]() {
        std::lock_guard<std::mutex> lock(items_mutex);
        crow::json::wvalue response;
        std::vector<crow::json::wvalue> items_json;
        
        for (const auto& item : items) {
            crow::json::wvalue item_json;
            item_json["id"] = item.id;
            item_json["name"] = item.name;
            item_json["description"] = item.description;
            items_json.push_back(std::move(item_json));
        }
        
        response["items"] = std::move(items_json);
        return response;
    });

    // GET /items/:id
    CROW_ROUTE(app, "/items/<int>")
    ([](int id) {
        std::lock_guard<std::mutex> lock(items_mutex);
        
        for (const auto& item : items) {
            if (item.id == id) {
                crow::json::wvalue response;
                response["id"] = item.id;
                response["name"] = item.name;
                response["description"] = item.description;
                return crow::response(200, response);
            }
        }
        
        crow::json::wvalue error;
        error["error"] = "Item not found";
        return crow::response(404, error);
    });

    // POST /items
    CROW_ROUTE(app, "/items").methods(crow::HTTPMethod::POST)
    ([](const crow::request& req) {
        auto body = crow::json::load(req.body);
        if (!body) {
            crow::json::wvalue error;
            error["error"] = "Invalid JSON";
            return crow::response(400, error);
        }

        std::lock_guard<std::mutex> lock(items_mutex);
        
        Item new_item;
        new_item.id = next_id++;
        new_item.name = body["name"].s();
        new_item.description = body["description"].s();
        items.push_back(new_item);

        crow::json::wvalue response;
        response["id"] = new_item.id;
        response["name"] = new_item.name;
        response["description"] = new_item.description;
        return crow::response(201, response);
    });

    // DELETE /items/:id
    CROW_ROUTE(app, "/items/<int>").methods(crow::HTTPMethod::DELETE)
    ([](int id) {
        std::lock_guard<std::mutex> lock(items_mutex);
        
        auto it = std::find_if(items.begin(), items.end(),
            [id](const Item& item) { return item.id == id; });
        
        if (it != items.end()) {
            items.erase(it);
            crow::json::wvalue response;
            response["message"] = "Item deleted";
            return crow::response(200, response);
        }
        
        crow::json::wvalue error;
        error["error"] = "Item not found";
        return crow::response(404, error);
    });

    std::cout << "Starting server on http://localhost:8080" << std::endl;
    app.port(8080).multithreaded().run();
    
    return 0;
}
`, projectName, projectName)
}

func (t *RESTTemplate) generateCMakeLists(projectName string, cppStandard int) string {
	return fmt.Sprintf(`cmake_minimum_required(VERSION 3.16)
project(%s VERSION 0.1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD %d)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find Crow
find_package(Crow CONFIG REQUIRED)

# Add executable
add_executable(${PROJECT_NAME}
    src/main.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(${PROJECT_NAME} PRIVATE
    Crow::Crow
)

# Copy compile_commands.json to project root
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_BINARY_DIR}/compile_commands.json
        ${CMAKE_SOURCE_DIR}/compile_commands.json
    )
endif()
`, projectName, cppStandard)
}

func (t *RESTTemplate) generateReadme(projectName string) string {
	return fmt.Sprintf(`# %s

A REST API server built with Crow framework.

## Building

`+"```"+`bash
cpx build
`+"```"+`

## Running

`+"```"+`bash
cpx run
`+"```"+`

The server starts on http://localhost:8080

## API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | / | API info |
| GET | /items | List all items |
| GET | /items/:id | Get item by ID |
| POST | /items | Create new item |
| DELETE | /items/:id | Delete item |

## Example Usage

`+"```"+`bash
# Get API info
curl http://localhost:8080/

# Create an item
curl -X POST http://localhost:8080/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Test", "description": "A test item"}'

# List all items
curl http://localhost:8080/items

# Get item by ID
curl http://localhost:8080/items/1

# Delete item
curl -X DELETE http://localhost:8080/items/1
`+"```"+`

## Dependencies

- Crow (C++ web framework)

## License

MIT
`, projectName)
}
