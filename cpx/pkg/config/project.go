package config

import (
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

// ToolchainConfig represents the cpx-ci.yaml structure for cross-compilation
type ToolchainConfig struct {
	Toolchains []Toolchain    `yaml:"toolchains"`
	Build      ToolchainBuild `yaml:"build"`
	Output     string         `yaml:"output"`
}

// DockerConfig represents Docker runner configuration
type DockerConfig struct {
	Image string `yaml:"image"` // Docker image name/tag (must exist locally)
}

// Toolchain represents a cross-compilation toolchain
type Toolchain struct {
	Name   string            `yaml:"name"`
	Active *bool             `yaml:"active,omitempty"` // true (default) or false to disable toolchain
	Runner string            `yaml:"runner,omitempty"` // docker (default), native
	Docker *DockerConfig     `yaml:"docker,omitempty"`
	Env    map[string]string `yaml:"env,omitempty"` // environment variables

	// Per-toolchain build configuration (overrides global build config)
	BuildType    string   `yaml:"build_type,omitempty"`    // Debug, Release, RelWithDebInfo, MinSizeRel
	CMakeOptions []string `yaml:"cmake_options,omitempty"` // additional CMake arguments
	BuildOptions []string `yaml:"build_options,omitempty"` // additional build arguments (cmake --build args)
}

// IsActive returns whether the toolchain is active (defaults to true if not specified)
func (t *Toolchain) IsActive() bool {
	if t.Active == nil {
		return true // default to active
	}
	return *t.Active
}

// ToolchainBuild represents toolchain build configuration
type ToolchainBuild struct {
	Type         string   `yaml:"type"`
	Optimization string   `yaml:"optimization"`
	Jobs         int      `yaml:"jobs"`
	CMakeArgs    []string `yaml:"cmake_args"`
	BuildArgs    []string `yaml:"build_args"`
	MesonArgs    []string `yaml:"meson_args"`
}

// LoadToolchains loads the toolchain configuration from cpx-ci.yaml
func LoadToolchains(path string) (*ToolchainConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var config ToolchainConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse cpx-ci.yaml: %w", err)
	}

	// Set defaults for build config
	if config.Output == "" {
		config.Output = filepath.Join(".bin", "ci")
	}
	if config.Build.Type == "" {
		config.Build.Type = "Release"
	}
	if config.Build.Optimization == "" {
		config.Build.Optimization = "2"
	}

	// Set defaults for each toolchain
	for i := range config.Toolchains {
		// Default runner is docker
		if config.Toolchains[i].Runner == "" {
			config.Toolchains[i].Runner = "docker"
		}

		// Default build type is Release
		if config.Toolchains[i].BuildType == "" {
			config.Toolchains[i].BuildType = "Release"
		}

	}

	return &config, nil
}

// SaveToolchains saves the toolchain configuration to cpx-ci.yaml
func SaveToolchains(config *ToolchainConfig, path string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal cpx-ci.yaml: %w", err)
	}

	// Add header comment
	header := "# cpx-ci.yaml - Toolchain configuration\n# Generated by cpx add-toolchain\n\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cpx-ci.yaml: %w", err)
	}

	return nil
}
